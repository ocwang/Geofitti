<!DOCTYPE html>
<!--[if IE 7]>
<html class="ie ie7" lang="en-US">
<![endif]-->
<!--[if IE 8]>
<html class="ie ie8" lang="en-US">
<![endif]-->
<!--[if !(IE 7) & !(IE 8)]><!-->
<html lang="en-US">
<!--<![endif]-->
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width">
	<title>WCMRenderingContext Class Reference | WILL SDK Docs</title>
	<link rel="profile" href="http://gmpg.org/xfn/11">
	<link rel="pingback" href="http://localhost/will_docs_instance1/xmlrpc.php">
	<!--[if lt IE 9]>
	<script src="http://localhost/will_docs_instance1/wp-content/themes/will-doc/js/html5.js"></script>
	<![endif]-->

	<link rel="stylesheet" href="../../wp-content/themes/will-doc/css/style.css">
	<link rel="stylesheet" href="../../wp-content/themes/will-doc/css/accordionmenu.css">

	<script src="../../wp-content/themes/will-doc/js/jquery.min.js"></script>
	<script src="../../wp-content/themes/will-doc/js/sidebar.js"></script>

	<link rel="stylesheet" href="../../wp-content/themes/will-doc/css/highlight.css">
	<script src="../../wp-content/themes/will-doc/js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
	<header>
		<div class="title">
			<div>WILL &trade;</div>
			<div>sdk documentation</div>
		</div>
		<!--
		<div id="searchbox">
			<input class="typeahead" type="text" placeholder="{{ search_text }}">
		</div>
-->
	</header>

	<div id="sitewrapper">
<div id="sidebar">
	<nav class="accordion">

				<h1 class="do-not-cause-collapse" title="General Concepts">

			General Concepts
			</h1>

							<div class="active-menu never-close">
					<h2 class="not-collapsible" title="Architectural Overview">

								<a href="../../general-concepts/architecture/index.html"
											>Architectural Overview</a>
					
			</h2>

						<h2 class="not-collapsible" title="Generating ink content">

								<a href="../../general-concepts/path-building/index.html"
											>Generating ink content</a>
					
			</h2>

						<h2 class="not-collapsible" title="Rendering ink content">

								<a href="../../general-concepts/rasterizer/index.html"
											>Rendering ink content</a>
					
			</h2>

						<h2 class="not-collapsible" title="Encoding and decoding ink content">

								<a href="../../general-concepts/serialization/index.html"
											>Encoding and decoding ink content</a>
					
			</h2>

						<h2 class="not-collapsible" title="Exchanging ink content">

								<a href="../../general-concepts/file-format/index.html"
											>Exchanging ink content</a>
					
			</h2>

							</div>
							<h1 title="iOS SDK">

			iOS SDK
			</h1>

							<div>
					<h2 title="Getting started">

								<a href="../getting-started/index.html"
											>Getting started</a>
					
			</h2>

						<h2 title="Release Notes">

								<a href="../release-notes/index.html"
											>Release Notes</a>
					
			</h2>

						<h2 title="Tutorials Overview">

								<a href="../tutorials/index.html"
											>Tutorials Overview</a>
					
			</h2>

							<div>
					<h3 title="Tutorial 1: Drawing with touch">

								<a href="../tutorials-tutorial1/index.html"
											>Tutorial 1: Drawing with touch</a>
					
			</h3>

							<div>
					<h4 title="Part 1: Setting up the ink engine">

								<a href="../tutorials-tutorial1-part1/index.html"
											>Part 1: Setting up the ink engine</a>
					
			</h4>

						<h4 title="Part 2: Building paths from touch input">

								<a href="../tutorials-tutorial1-part2/index.html"
											>Part 2: Building paths from touch input</a>
					
			</h4>

						<h4 title="Part 3: Smoothing paths">

								<a href="../tutorials-tutorial1-part3/index.html"
											>Part 3: Smoothing paths</a>
					
			</h4>

						<h4 title="Part 4: Drawing semi-transparent strokes">

								<a href="../tutorials-tutorial1-part4/index.html"
											>Part 4: Drawing semi-transparent strokes</a>
					
			</h4>

						<h4 title="Part 5: Drawing preliminary paths">

								<a href="../tutorials-tutorial1-part5/index.html"
											>Part 5: Drawing preliminary paths</a>
					
			</h4>

						<h4 title="Part 6: Using a particle brush">

								<a href="../tutorials-tutorial1-part6/index.html"
											>Part 6: Using a particle brush</a>
					
			</h4>

						<h4 title="Part 7: Generating a Bezier path">

								<a href="../tutorials-tutorial1-part7/index.html"
											>Part 7: Generating a Bezier path</a>
					
			</h4>

							</div>
							<h3 title="Tutorial 2: Encoding and decoding strokes">

								<a href="../tutorials-tutorial2/index.html"
											>Tutorial 2: Encoding and decoding strokes</a>
					
			</h3>

							<div>
					<h4 title="Part 1: Creating a stroke model">

								<a href="../tutorials-tutorial2-part1/index.html"
											>Part 1: Creating a stroke model</a>
					
			</h4>

						<h4 title="Part 2: Serializing and deserializing strokes">

								<a href="../tutorials-tutorial2-part2/index.html"
											>Part 2: Serializing and deserializing strokes</a>
					
			</h4>

							</div>
							<h3 title="Tutorial 3: Erasing strokes">

								<a href="../tutorials-tutorial3/index.html"
											>Tutorial 3: Erasing strokes</a>
					
			</h3>

							<div>
					<h4 title="Part 1: Extending the stroke model">

								<a href="../tutorials-tutorial3-part1/index.html"
											>Part 1: Extending the stroke model</a>
					
			</h4>

						<h4 title="Part 2: Creating an eraser">

								<a href="../tutorials-tutorial3-part2/index.html"
											>Part 2: Creating an eraser</a>
					
			</h4>

						<h4 title="Part 3: Erasing parts of strokes">

								<a href="../tutorials-tutorial3-part3/index.html"
											>Part 3: Erasing parts of strokes</a>
					
			</h4>

							</div>
							<h3 title="Tutorial 4: Selecting strokes">

								<a href="../tutorials-tutorial4/index.html"
											>Tutorial 4: Selecting strokes</a>
					
			</h3>

							<div>
					<h4 title="Part 1: Selecting whole strokes">

								<a href="../tutorials-tutorial4-part1/index.html"
											>Part 1: Selecting whole strokes</a>
					
			</h4>

						<h4 title="Part 2: Selecting parts of strokes">

								<a href="../tutorials-tutorial4-part2/index.html"
											>Part 2: Selecting parts of strokes</a>
					
			</h4>

							</div>
							<h3 title="Tutorial 5: Working with rasters">

								<a href="../tutorials-tutorial5/index.html"
											>Tutorial 5: Working with rasters</a>
					
			</h3>

							<div>
					<h4 title="Part 1: Displaying raster images">

								<a href="../tutorials-tutorial5-part1/index.html"
											>Part 1: Displaying raster images</a>
					
			</h4>

						<h4 title="Part 2: Creating image masks">

								<a href="../tutorials-tutorial5-part2/index.html"
											>Part 2: Creating image masks</a>
					
			</h4>

							</div>
								</div>
							<h2 title="API Reference">

			API Reference
			</h2>

							<div>
					<h3 title="Classes">

			Classes
			</h3>

							<div>
					<h4 title="WCMAbstractPathBuilder">

								<a href="../api-WCMAbstractPathBuilder/index.html"
											>WCMAbstractPathBuilder</a>
					
			</h4>

						<h4 title="WCMBezierPathUtils">

								<a href="../api-WCMBezierPathUtils/index.html"
											>WCMBezierPathUtils</a>
					
			</h4>

						<h4 title="WCMCGRectVector">

								<a href="../api-WCMCGRectVector/index.html"
											>WCMCGRectVector</a>
					
			</h4>

						<h4 title="WCMDirectStrokeBrush">

								<a href="../api-WCMDirectStrokeBrush/index.html"
											>WCMDirectStrokeBrush</a>
					
			</h4>

						<h4 title="WCMDocument">

								<a href="../api-WCMDocument/index.html"
											>WCMDocument</a>
					
			</h4>

						<h4 title="WCMDocumentContentType">

								<a href="../api-WCMDocumentContentType/index.html"
											>WCMDocumentContentType</a>
					
			</h4>

						<h4 title="WCMDocumentProperties">

								<a href="../api-WCMDocumentProperties/index.html"
											>WCMDocumentProperties</a>
					
			</h4>

						<h4 title="WCMDocumentResource">

								<a href="../api-WCMDocumentResource/index.html"
											>WCMDocumentResource</a>
					
			</h4>

						<h4 title="WCMDocumentSection">

								<a href="../api-WCMDocumentSection/index.html"
											>WCMDocumentSection</a>
					
			</h4>

						<h4 title="WCMDocumentSectionContainer">

								<a href="../api-WCMDocumentSectionContainer/index.html"
											>WCMDocumentSectionContainer</a>
					
			</h4>

						<h4 title="WCMDocumentSectionElement">

								<a href="../api-WCMDocumentSectionElement/index.html"
											>WCMDocumentSectionElement</a>
					
			</h4>

						<h4 title="WCMDocumentSectionGroup">

								<a href="../api-WCMDocumentSectionGroup/index.html"
											>WCMDocumentSectionGroup</a>
					
			</h4>

						<h4 title="WCMDocumentSectionImage">

								<a href="../api-WCMDocumentSectionImage/index.html"
											>WCMDocumentSectionImage</a>
					
			</h4>

						<h4 title="WCMDocumentSectionPaths">

								<a href="../api-WCMDocumentSectionPaths/index.html"
											>WCMDocumentSectionPaths</a>
					
			</h4>

						<h4 title="WCMDocumentSectionRect">

								<a href="../api-WCMDocumentSectionRect/index.html"
											>WCMDocumentSectionRect</a>
					
			</h4>

						<h4 title="WCMDocumentSectionView">

								<a href="../api-WCMDocumentSectionView/index.html"
											>WCMDocumentSectionView</a>
					
			</h4>

						<h4 title="WCMFloatVector">

								<a href="../api-WCMFloatVector/index.html"
											>WCMFloatVector</a>
					
			</h4>

						<h4 title="WCMFloatVectorPointer">

								<a href="../api-WCMFloatVectorPointer/index.html"
											>WCMFloatVectorPointer</a>
					
			</h4>

						<h4 title="WCMInkDecoder">

								<a href="../api-WCMInkDecoder/index.html"
											>WCMInkDecoder</a>
					
			</h4>

						<h4 title="WCMInkEncoder">

								<a href="../api-WCMInkEncoder/index.html"
											>WCMInkEncoder</a>
					
			</h4>

						<h4 title="WCMIntVector">

								<a href="../api-WCMIntVector/index.html"
											>WCMIntVector</a>
					
			</h4>

						<h4 title="WCMIntersector">

								<a href="../api-WCMIntersector/index.html"
											>WCMIntersector</a>
					
			</h4>

						<h4 title="WCMLayer">

								<a href="../api-WCMLayer/index.html"
											>WCMLayer</a>
					
			</h4>

						<h4 title="WCMMultiChannelSmoothener">

								<a href="../api-WCMMultiChannelSmoothener/index.html"
											>WCMMultiChannelSmoothener</a>
					
			</h4>

						<h4 title="WCMPaintDecoder">

								<a href="../api-WCMPaintDecoder/index.html"
											>WCMPaintDecoder</a>
					
			</h4>

						<h4 title="WCMPaintEncoder">

								<a href="../api-WCMPaintEncoder/index.html"
											>WCMPaintEncoder</a>
					
			</h4>

						<h4 title="WCMParticlePaint">

								<a href="../api-WCMParticlePaint/index.html"
											>WCMParticlePaint</a>
					
			</h4>

						<h4 title="WCMParticleStrokeBrush">

								<a href="../api-WCMParticleStrokeBrush/index.html"
											>WCMParticleStrokeBrush</a>
					
			</h4>

						<h4 title="WCMPathAppendResult">

								<a href="../api-WCMPathAppendResult/index.html"
											>WCMPathAppendResult</a>
					
			</h4>

						<h4 title="WCMPressurePathBuilder">

								<a href="../api-WCMPressurePathBuilder/index.html"
											>WCMPressurePathBuilder</a>
					
			</h4>

						<h4 title="WCMRIFFChunk">

								<a href="../api-WCMRIFFChunk/index.html"
											>WCMRIFFChunk</a>
					
			</h4>

						<h4 title="WCMRIFFDecoder">

								<a href="../api-WCMRIFFDecoder/index.html"
											>WCMRIFFDecoder</a>
					
			</h4>

						<h4 title="WCMRIFFEncoder">

								<a href="../api-WCMRIFFEncoder/index.html"
											>WCMRIFFEncoder</a>
					
			</h4>

						<h4 title="WCMRenderingContext">

								<a href="index.html"
						 class="selected"					>WCMRenderingContext</a>
					
			</h4>

						<h4 title="WCMSmoothener">

								<a href="../api-WCMSmoothener/index.html"
											>WCMSmoothener</a>
					
			</h4>

						<h4 title="WCMSmoothenerFinisher">

								<a href="../api-WCMSmoothenerFinisher/index.html"
											>WCMSmoothenerFinisher</a>
					
			</h4>

						<h4 title="WCMSolidColorStrokeBrush">

								<a href="../api-WCMSolidColorStrokeBrush/index.html"
											>WCMSolidColorStrokeBrush</a>
					
			</h4>

						<h4 title="WCMSpeedPathBuilder">

								<a href="../api-WCMSpeedPathBuilder/index.html"
											>WCMSpeedPathBuilder</a>
					
			</h4>

						<h4 title="WCMStrokeBrush">

								<a href="../api-WCMStrokeBrush/index.html"
											>WCMStrokeBrush</a>
					
			</h4>

						<h4 title="WCMStrokeRenderer">

								<a href="../api-WCMStrokeRenderer/index.html"
											>WCMStrokeRenderer</a>
					
			</h4>

						<h4 title="WCMTransformableProtocol">

								<a href="../api-WCMTransformableProtocol/index.html"
											>WCMTransformableProtocol</a>
					
			</h4>

						<h4 title="WCMVersion">

								<a href="../api-WCMVersion/index.html"
											>WCMVersion</a>
					
			</h4>

						<h4 title="WCMWILLFileFormatDecoder">

								<a href="../api-WCMWILLFileFormatDecoder/index.html"
											>WCMWILLFileFormatDecoder</a>
					
			</h4>

						<h4 title="WCMWILLFileFormatEncoder">

								<a href="../api-WCMWILLFileFormatEncoder/index.html"
											>WCMWILLFileFormatEncoder</a>
					
			</h4>

							</div>
							<h3 title="Constants">

			Constants
			</h3>

							<div>
					<h4 title="WCMBlendMode">

								<a href="../api-WCMBlendMode/index.html"
											>WCMBlendMode</a>
					
			</h4>

						<h4 title="WCMInputPhase">

								<a href="../api-WCMInputPhase/index.html"
											>WCMInputPhase</a>
					
			</h4>

						<h4 title="WCMPropertyFunction">

								<a href="../api-WCMPropertyFunction/index.html"
											>WCMPropertyFunction</a>
					
			</h4>

						<h4 title="WCMPropertyName">

								<a href="../api-WCMPropertyName/index.html"
											>WCMPropertyName</a>
					
			</h4>

						<h4 title="WCMStrokeBrushRotation">

								<a href="../api-WCMStrokeBrushRotation/index.html"
											>WCMStrokeBrushRotation</a>
					
			</h4>

							</div>
							<h3 title="Index">

								<a href="../api-index/index.html"
											>Index</a>
					
			</h3>

						<h3 title="Hierarchy">

								<a href="../api-hierarchy/index.html"
											>Hierarchy</a>
					
			</h3>

			
	</nav>
</div><div id="page_content" class='page-content api ios'>
	
<div id="post-42" class="page">
	<h1>WCMRenderingContext Class Reference</h1>
<p><a href="../api-index/index.html">Index</a> | <a href="../api-hierarchy/index.html">Hierarchy</a></p>
<p>Inherits from | NSObject
Declared in | WacomInkRasterizer.h</p>
<p>Available in <em>1.2</em> and later.</p>
<h2>Overview</h2>
<hr />
<p>The WCMRenderingContext class is a graphics context that is used to render visual objects like strokes and layers, to fill paths and others. It has some similarity with the Quartz 2D's CGContext. It is build on top of OpenGL ES and acts as a wrapper of a <em>EAGLContext</em>. The destination of draw operations is always a instance of the <a href="../api-WCMLayer/index.html">WCMLayer</a> class. This class is also responsible for creating an initializing instances of the <a href="../api-WCMLayer/index.html">WCMLayer</a> class. A <a href="../api-WCMLayer/index.html">WCMLayer</a> could represent the screen, a texture or an offscreen render buffer.</p>
<h2>Tasks</h2>
<hr />
<h3>Creating a Rendering Context</h3>
<p><a href="index.html#//api/name/contextWithEAGLContext:">+&nbsp;contextWithEAGLContext:</a>  </p>
<h3>Initializing a Rendering Context</h3>
<p><a href="index.html#//api/name/initWithEAGLContext:">&ndash;&nbsp;initWithEAGLContext:</a>  </p>
<h3>EAGLContext Access</h3>
<p><a href="index.html#//api/name/eaglContext">&nbsp;&nbsp;eaglContext</a> property </p>
<h3>Creating a WCMStrokeBrush</h3>
<p><a href="index.html#//api/name/solidColorBrush">&ndash;&nbsp;solidColorBrush</a>  </p>
<p><a href="index.html#//api/name/directBrush">&ndash;&nbsp;directBrush</a>  </p>
<p><a href="index.html#//api/name/directBrushWithBlendMode:">&ndash;&nbsp;directBrushWithBlendMode:</a>  </p>
<p><a href="index.html#//api/name/particleBrushWithFillImage:andShapeImage:andSpacing:andScattering:andBlendMode:andRotation:">&ndash;&nbsp;particleBrushWithFillImage:andShapeImage:andSpacing:andScattering:andBlendMode:andRotation:</a>  </p>
<p><a href="index.html#//api/name/particleBrushWithFillImage:andShapeMipmapLevelsImages:andSpacing:andScattering:andBlendMode:andRotation:">&ndash;&nbsp;particleBrushWithFillImage:andShapeMipmapLevelsImages:andSpacing:andScattering:andBlendMode:andRotation:</a>  </p>
<p><a href="index.html#//api/name/particleBrushWithFillMipmapLevelsImages:andFillTileSize:andShapeMipmapLevelsImages:andSpacing:andScattering:andBlendMode:andRotation:">&ndash;&nbsp;particleBrushWithFillMipmapLevelsImages:andFillTileSize:andShapeMipmapLevelsImages:andSpacing:andScattering:andBlendMode:andRotation:</a>  </p>
<p><a href="index.html#//api/name/particleBrushWithPaint:">&ndash;&nbsp;particleBrushWithPaint:</a>  </p>
<h3>Creating a WCMStrokeRenderer</h3>
<p><a href="index.html#//api/name/strokeRendererWithSize:andScaleFactor:">&ndash;&nbsp;strokeRendererWithSize:andScaleFactor:</a>  </p>
<p><a href="index.html#//api/name/strokeRenderertWithBufferLayer:">&ndash;&nbsp;strokeRenderertWithBufferLayer:</a>  </p>
<p><a href="index.html#//api/name/strokeRenderertWithBufferLayer:andPreliminaryBufferLayer:">&ndash;&nbsp;strokeRenderertWithBufferLayer:andPreliminaryBufferLayer:</a>  </p>
<h3>Creating a WCMLayer</h3>
<p><a href="index.html#//api/name/layerWithWidth:andHeight:">&ndash;&nbsp;layerWithWidth:andHeight:</a>  </p>
<p><a href="index.html#//api/name/layerWithWidth:andHeight:andScaleFactor:">&ndash;&nbsp;layerWithWidth:andHeight:andScaleFactor:</a>  </p>
<p><a href="index.html#//api/name/layerWithWidth:andHeight:andScaleFactor:andUseTextureStorage:">&ndash;&nbsp;layerWithWidth:andHeight:andScaleFactor:andUseTextureStorage:</a>  </p>
<p><a href="index.html#//api/name/layerWithWidth:andHeight:andScaleFactor:andGlFramebufferId:andGlRenderbufferId:andGlTextureId:ownGlResources:">&ndash;&nbsp;layerWithWidth:andHeight:andScaleFactor:andGlFramebufferId:andGlRenderbufferId:andGlTextureId:ownGlResources:</a>  </p>
<p><a href="index.html#//api/name/layerFromEAGLDrawable:withScaleFactor:">&ndash;&nbsp;layerFromEAGLDrawable:withScaleFactor:</a>  </p>
<p><a href="index.html#//api/name/resizeLayer:withEAGLDrawable:">&ndash;&nbsp;resizeLayer:withEAGLDrawable:</a>  </p>
<p><a href="index.html#//api/name/resizeLayer:withSize:">&ndash;&nbsp;resizeLayer:withSize:</a>  </p>
<h3>Setting a rendering target</h3>
<p><a href="index.html#//api/name/setTarget:">&ndash;&nbsp;setTarget:</a>  </p>
<p><a href="index.html#//api/name/setTarget:andClipRect:">&ndash;&nbsp;setTarget:andClipRect:</a>  </p>
<p><a href="index.html#//api/name/currentTarget">&ndash;&nbsp;currentTarget</a>  </p>
<h3>Clear Color</h3>
<p><a href="index.html#//api/name/clearColorWithRed:AndGreen:andBlue:andAlpha:">&ndash;&nbsp;clearColorWithRed:AndGreen:andBlue:andAlpha:</a>  </p>
<p><a href="index.html#//api/name/clearColor:">&ndash;&nbsp;clearColor:</a>  </p>
<h3>Manage the Clipping Rectangle</h3>
<p><a href="index.html#//api/name/setTargetClipRect:">&ndash;&nbsp;setTargetClipRect:</a>  </p>
<p><a href="index.html#//api/name/clipRect">&ndash;&nbsp;clipRect</a>  </p>
<p><a href="index.html#//api/name/disableTargetClipRect">&ndash;&nbsp;disableTargetClipRect</a>  </p>
<h3>Draw Stroke</h3>
<p><a href="index.html#//api/name/drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:">&ndash;&nbsp;drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:</a>  </p>
<p><a href="index.html#//api/name/drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:andTs:andTf:andLastParticle:andRandomSeed:">&ndash;&nbsp;drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:andTs:andTf:andLastParticle:andRandomSeed:</a>  </p>
<p><a href="index.html#//api/name/drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:andTs:andTf:andLastParticle:andRandomSeed:andCheckBounds:">&ndash;&nbsp;drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:andTs:andTf:andLastParticle:andRandomSeed:andCheckBounds:</a>  </p>
<h3>Fill Path</h3>
<p><a href="index.html#//api/name/fillPath:andBufferSize:andStride:andColor:andAntiAliased:">&ndash;&nbsp;fillPath:andBufferSize:andStride:andColor:andAntiAliased:</a>  </p>
<h3>Draw Layer</h3>
<p><a href="index.html#//api/name/drawLayer:">&ndash;&nbsp;drawLayer:</a>  </p>
<p><a href="index.html#//api/name/drawLayer:withBlendMode:">&ndash;&nbsp;drawLayer:withBlendMode:</a>  </p>
<p><a href="index.html#//api/name/drawLayer:withTransform:andBlendMode:">&ndash;&nbsp;drawLayer:withTransform:andBlendMode:</a>  </p>
<p><a href="index.html#//api/name/drawLayer:withTransform:andBlendMode:andAntiAliasedEdges:">&ndash;&nbsp;drawLayer:withTransform:andBlendMode:andAntiAliasedEdges:</a>  </p>
<p><a href="index.html#//api/name/drawLayer:withSourceRect:andSourceTransform:andDestinationRect:andDestinationTransform:andBlendMode:andAntiAliasedEdges:">&ndash;&nbsp;drawLayer:withSourceRect:andSourceTransform:andDestinationRect:andDestinationTransform:andBlendMode:andAntiAliasedEdges:</a>  </p>
<p><a href="index.html#//api/name/drawLayer:withSourceRect:andDestinationRect:andBlendMode:">&ndash;&nbsp;drawLayer:withSourceRect:andDestinationRect:andBlendMode:</a>  </p>
<p><a href="index.html#//api/name/drawLayer:withSourceQuad:andDestinationQuad:andBlendMode:">&ndash;&nbsp;drawLayer:withSourceQuad:andDestinationQuad:andBlendMode:</a>  </p>
<h3>Read Layer Pixels</h3>
<p><a href="index.html#//api/name/readPixelsFromCurrentTarget">&ndash;&nbsp;readPixelsFromCurrentTarget</a>  </p>
<p><a href="index.html#//api/name/readPixelsAsUIImageFromCurrentTarget">&ndash;&nbsp;readPixelsAsUIImageFromCurrentTarget</a>  </p>
<p><a href="index.html#//api/name/readPixelsAsUIImageFromCurrentTargetInUpOrientation">&ndash;&nbsp;readPixelsAsUIImageFromCurrentTargetInUpOrientation</a>  </p>
<p><a href="index.html#//api/name/readPixelsFromCurrentTargetFromRect:">&ndash;&nbsp;readPixelsFromCurrentTargetFromRect:</a>  </p>
<p><a href="index.html#//api/name/readPixelsAsUIImageFromCurrentTargetFromRect:">&ndash;&nbsp;readPixelsAsUIImageFromCurrentTargetFromRect:</a>  </p>
<p><a href="index.html#//api/name/readPixelsAsUIImageFromCurrentTargetFromRectInUpOrientation:">&ndash;&nbsp;readPixelsAsUIImageFromCurrentTargetFromRectInUpOrientation:</a>  </p>
<h3>Write Layer Pixels</h3>
<p><a href="index.html#//api/name/writePixelsInCurrentTarget:">&ndash;&nbsp;writePixelsInCurrentTarget:</a>  </p>
<p><a href="index.html#//api/name/writePixelsInCurrentTargetFromUIImage:">&ndash;&nbsp;writePixelsInCurrentTargetFromUIImage:</a>  </p>
<p><a href="index.html#//api/name/writePixelsInCurrentTarget:inRect:">&ndash;&nbsp;writePixelsInCurrentTarget:inRect:</a>  </p>
<p><a href="index.html#//api/name/writePixelsInCurrentTargetFromUIImage:inRect:">&ndash;&nbsp;writePixelsInCurrentTargetFromUIImage:inRect:</a>  </p>
<h2>Properties</h2>
<hr />
<p><a name="//api/name/eaglContext" title="eaglContext"></a></p>
<h4>eaglContext</h4>
<p>Returns the EAGLContext instance associated with the rendering context. All OpenGL resources created by the rendering context belong the this EAGLContext.  </p>
<pre><code class="objectivec">@property (readonly, strong) EAGLContext *eaglContext</code></pre>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; the EAGLContext instance associated with the rendering context.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<h2>Class Methods</h2>
<hr />
<p><a name="//api/name/contextWithEAGLContext:" title="contextWithEAGLContext:"></a></p>
<h4>contextWithEAGLContext:</h4>
<p>Creates and returns a rendering context, initialized with an instance of the <em>EAGLContext</em> class.   </p>
<pre><code class="objectivec">+ (WCMRenderingContext *)contextWithEAGLContext:(EAGLContext *)eaglContext</code></pre>
<h5>Parameters</h5>
<p><em>eaglContext</em></p>
<p>&nbsp;&nbsp; The EAGLContext instance associated with the rendering context. All OpengGL operations and resources (like textures or render buffers) will be for this context.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; an initialized instance of the WCMRenderingContext class.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<h2>Instance Methods</h2>
<hr />
<p><a name="//api/name/clearColor:" title="clearColor:"></a></p>
<h4>clearColor:</h4>
<p>Clears the current target with a color specified by the color.  </p>
<pre><code class="objectivec">- (void)clearColor:(UIColor *)color</code></pre>
<h5>Parameters</h5>
<p><em>color</em></p>
<p>&nbsp;&nbsp; The color parameter.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; Non-premultiplied colors are expected.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/clearColorWithRed:AndGreen:andBlue:andAlpha:" title="clearColorWithRed:AndGreen:andBlue:andAlpha:"></a></p>
<h4>clearColorWithRed:AndGreen:andBlue:andAlpha:</h4>
<p>Clears the current target with a color specified by channels values. Channels are in the rage 0 to 1.   </p>
<pre><code class="objectivec">- (void)clearColorWithRed:(float)red AndGreen:(float)green andBlue:(float)blue andAlpha:(float)alpha</code></pre>
<h5>Parameters</h5>
<p><em>red</em></p>
<p>&nbsp;&nbsp; The red channel of the color. In the range 0 to 1.</p>
<p><em>green</em></p>
<p>&nbsp;&nbsp; The green channel of the color. In the range 0 to 1.</p>
<p><em>blue</em></p>
<p>&nbsp;&nbsp; The blue channel of the color. In the range 0 to 1.</p>
<p><em>alpha</em></p>
<p>&nbsp;&nbsp; The alpha channel of the color. In the range 0 to 1.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; Non-premultiplied colors are expected.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/clipRect" title="clipRect"></a></p>
<h4>clipRect</h4>
<p>@abstarct Returns the current clip rect set by the <a href="index.html#//api/name/setTargetClipRect:">[WCMRenderingContext setTargetClipRect:]</a> method.   </p>
<pre><code class="objectivec">- (CGRect)clipRect</code></pre>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; The current clip rect set by the <a href="index.html#//api/name/setTargetClipRect:">[WCMRenderingContext setTargetClipRect:]</a> method.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; @abstarct Returns the current clip rect set by the <a href="index.html#//api/name/setTargetClipRect:">[WCMRenderingContext setTargetClipRect:]</a> method.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/currentTarget" title="currentTarget"></a></p>
<h4>currentTarget</h4>
<p>@abstarct Returns the WCMLayer set by the <a href="index.html#//api/name/setTarget:">[WCMRenderingContext setTarget:]</a> or [WCMRenderingContext <a href="index.html#//api/name/setTarget:">setTarget:</a> andClipRect:] methods.    </p>
<pre><code class="objectivec">- (WCMLayer *)currentTarget</code></pre>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; The WCMLayer set by the <a href="index.html#//api/name/setTarget:">[WCMRenderingContext setTarget:]</a> or [WCMRenderingContext <a href="index.html#//api/name/setTarget:">setTarget:</a> andClipRect:] methods.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; @abstarct Returns the WCMLayer set by the <a href="index.html#//api/name/setTarget:">[WCMRenderingContext setTarget:]</a> or [WCMRenderingContext <a href="index.html#//api/name/setTarget:">setTarget:</a> andClipRect:] methods.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/directBrush" title="directBrush"></a></p>
<h4>directBrush</h4>
<p>Creates and returns initialized <a href="../api-WCMStrokeBrush/index.html">WCMStrokeBrush</a> instance. Strokes draw with this brush will be filled with a solid color.
This brush is fast but unlike <a href="../api-WCMSolidColorStrokeBrush/index.html">WCMSolidColorStrokeBrush</a>, strokes drawn with it could have glitches for paths that vary sharply.
It is recommended to use the <a href="../api-WCMSolidColorStrokeBrush/index.html">WCMSolidColorStrokeBrush</a> instead, unless you really need the performance gain and you will draw smoothed out paths.  </p>
<pre><code class="objectivec">- (WCMDirectStrokeBrush *)directBrush</code></pre>
<h5>Availability</h5>
<p>Available in <em>1.3</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/directBrushWithBlendMode:" title="directBrushWithBlendMode:"></a></p>
<h4>directBrushWithBlendMode:</h4>
<p>Creates and returns initialized <a href="../api-WCMStrokeBrush/index.html">WCMStrokeBrush</a> instance with custom blend mode. Strokes draw with this brush will be filled with a solid color.
This brush is fast but unlike <a href="../api-WCMSolidColorStrokeBrush/index.html">WCMSolidColorStrokeBrush</a>, strokes drawn with it could have glitches for paths that vary sharply.
It is recommended to use the <a href="../api-WCMSolidColorStrokeBrush/index.html">WCMSolidColorStrokeBrush</a> instead, unless you really need the performance gain and you draw only smoothed out paths.  </p>
<pre><code class="objectivec">- (WCMDirectStrokeBrush *)directBrushWithBlendMode:(WCMBlendMode)blendMode</code></pre>
<h5>Parameters</h5>
<p><em>blendMode</em></p>
<p>&nbsp;&nbsp; Specifies the blend mode used.</p>
<h5>Availability</h5>
<p>Available in <em>1.3</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/disableTargetClipRect" title="disableTargetClipRect"></a></p>
<h4>disableTargetClipRect</h4>
<p>Disables the clipping rect. See <a href="index.html#//api/name/setTargetClipRect:">[WCMRenderingContext setTargetClipRect:]</a>. </p>
<pre><code class="objectivec">- (void)disableTargetClipRect</code></pre>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; This call will lead to glDisable of the GL_SCISSOR_TEST call.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/drawLayer:" title="drawLayer:"></a></p>
<h4>drawLayer:</h4>
<p>Draws the content of the layer into the current target layer.   </p>
<pre><code class="objectivec">- (void)drawLayer:(WCMLayer *)layer</code></pre>
<h5>Parameters</h5>
<p><em>layer</em></p>
<p>&nbsp;&nbsp; The layer to be drawn.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; The layer drawn must use a texture storage. The layer content is drawn at (0,0) with a normal blend mode.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/drawLayer:withBlendMode:" title="drawLayer:withBlendMode:"></a></p>
<h4>drawLayer:withBlendMode:</h4>
<p>Draws the content of the layer into the current target layer.   </p>
<pre><code class="objectivec">- (void)drawLayer:(WCMLayer *)layer withBlendMode:(WCMBlendMode)blendMode</code></pre>
<h5>Parameters</h5>
<p><em>layer</em></p>
<p>&nbsp;&nbsp; The layer to be drawn.</p>
<p><em>blendMode</em></p>
<p>&nbsp;&nbsp; The blend mode used.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; The layer must use a texture storage. The layer content is drawn at (0,0)</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/drawLayer:withSourceQuad:andDestinationQuad:andBlendMode:" title="drawLayer:withSourceQuad:andDestinationQuad:andBlendMode:"></a></p>
<h4>drawLayer:withSourceQuad:andDestinationQuad:andBlendMode:</h4>
<p>Draws the content of the layer into the current target layer. (<b class="deprecated">Deprecated:</b><span class="deprecated"> in 1.3. This method could produce unexpected results in texture sampling when passing quadrilaterals that are not the result of affine transformation applied to a rectangle. It is suggested to use the [WCMRenderingContext drawLayer: withSourceRect: andSourceTransform: andDestinationRect: andDestinationTransform: andBlendMode: andAntiAliasedEdges:] instead.</span>)    </p>
<pre><code class="objectivec">- (void)drawLayer:(WCMLayer *)layer withSourceQuad:(WCMQuad)sourceQuad andDestinationQuad:(WCMQuad)destinationQuad andBlendMode:(WCMBlendMode)blendMode</code></pre>
<h5>Parameters</h5>
<p><em>layer</em></p>
<p>&nbsp;&nbsp; The layer that is drawn.</p>
<p><em>sourceQuad</em></p>
<p>&nbsp;&nbsp; Specifies a quadrilateral area from the the drawn layer. Only that portion of the layer will be drawn. <b>The sourceQuad must be convex.</b></p>
<p><em>destinationQuad</em></p>
<p>&nbsp;&nbsp; Specifies a quadrilateral area from the target layer. The content of the sourceQuad will be stretched so it fills the destinationQuad entirely. <b>The destinationQuad must be convex.</b></p>
<p><em>blendMode</em></p>
<p>&nbsp;&nbsp; The blend mode used.</p>
<h5>Availability</h5>
<p>Available in *1.2*<em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; The layer must use a texture storage.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/drawLayer:withSourceRect:andDestinationRect:andBlendMode:" title="drawLayer:withSourceRect:andDestinationRect:andBlendMode:"></a></p>
<h4>drawLayer:withSourceRect:andDestinationRect:andBlendMode:</h4>
<p>Draws the content of the layer into the current target layer.   </p>
<pre><code class="objectivec">- (void)drawLayer:(WCMLayer *)layer withSourceRect:(CGRect)sourceRect andDestinationRect:(CGRect)destinationRect andBlendMode:(WCMBlendMode)blendMode</code></pre>
<h5>Parameters</h5>
<p><em>layer</em></p>
<p>&nbsp;&nbsp; The layer to be drawn.</p>
<p><em>sourceRect</em></p>
<p>&nbsp;&nbsp; Specifies a rectangular area from the drawn layer. Only that portion of the layer will be drawn.</p>
<p><em>destinationRect</em></p>
<p>&nbsp;&nbsp; Specifies a rectangular area from the target layer. The content of the sourceRect will be stretched so it fills the destinationRect entirely.</p>
<p><em>blendMode</em></p>
<p>&nbsp;&nbsp; The blend mode used.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; The layer must use a texture storage.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/drawLayer:withSourceRect:andSourceTransform:andDestinationRect:andDestinationTransform:andBlendMode:andAntiAliasedEdges:" title="drawLayer:withSourceRect:andSourceTransform:andDestinationRect:andDestinationTransform:andBlendMode:andAntiAliasedEdges:"></a></p>
<h4>drawLayer:withSourceRect:andSourceTransform:andDestinationRect:andDestinationTransform:andBlendMode:andAntiAliasedEdges:</h4>
<p>Draws the content of the layer into the current target layer.   </p>
<pre><code class="objectivec">- (void)drawLayer:(WCMLayer *)layer withSourceRect:(CGRect)sourceRect andSourceTransform:(CGAffineTransform)sourceTransform andDestinationRect:(CGRect)destinationRect andDestinationTransform:(CGAffineTransform)destinationTransform andBlendMode:(WCMBlendMode)blendMode andAntiAliasedEdges:(BOOL)antiAliasedEdges</code></pre>
<h5>Parameters</h5>
<p><em>layer</em></p>
<p>&nbsp;&nbsp; The layer to be drawn.</p>
<p><em>sourceRect</em></p>
<p>&nbsp;&nbsp; Specifies a rectangular area from the drawn layer. Only that portion of the layer will be drawn. The rect will be transformed by sourceTransform parameter.</p>
<p><em>sourceTransform</em></p>
<p>&nbsp;&nbsp; Specifies an affine transformation applied to the sourceRect parameter.</p>
<p><em>destinationRect</em></p>
<p>&nbsp;&nbsp; Specifies a rectangular area from the target layer. The content of the tranformed sourceRect will be stretched so it fills the transformed destinationRect entirely.</p>
<p><em>destinationTransform</em></p>
<p>&nbsp;&nbsp; Specifies an affine transformation applied to the destinationRect parameter.</p>
<p><em>blendMode</em></p>
<p>&nbsp;&nbsp; The blend mode used.</p>
<p><em>antiAliasedEdges</em></p>
<p>&nbsp;&nbsp; Flag indicating whether or not to anti-alias the edges of the layer drawn. The anti-aliasing accomplished by drawing a thin gradient stripes going to alpha 0, along the edges.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; The layer must use a texture storage. The content is drawn transformed with the transform parameter.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/drawLayer:withTransform:andBlendMode:" title="drawLayer:withTransform:andBlendMode:"></a></p>
<h4>drawLayer:withTransform:andBlendMode:</h4>
<p>Draws the content of the layer into the current target layer.   </p>
<pre><code class="objectivec">- (void)drawLayer:(WCMLayer *)layer withTransform:(CGAffineTransform *)transform andBlendMode:(WCMBlendMode)blendMode</code></pre>
<h5>Parameters</h5>
<p><em>layer</em></p>
<p>&nbsp;&nbsp; The layer to be drawn.</p>
<p><em>transform</em></p>
<p>&nbsp;&nbsp; Transformation of the layer drawn.</p>
<p><em>blendMode</em></p>
<p>&nbsp;&nbsp; The blend mode used.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; The layer must use a texture storage. The content is drawn transformed with the transform parameter.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/drawLayer:withTransform:andBlendMode:andAntiAliasedEdges:" title="drawLayer:withTransform:andBlendMode:andAntiAliasedEdges:"></a></p>
<h4>drawLayer:withTransform:andBlendMode:andAntiAliasedEdges:</h4>
<p>Draws the content of the layer into the current target layer.   </p>
<pre><code class="objectivec">- (void)drawLayer:(WCMLayer *)layer withTransform:(CGAffineTransform *)transform andBlendMode:(WCMBlendMode)blendMode andAntiAliasedEdges:(BOOL)antiAliasedEdges</code></pre>
<h5>Parameters</h5>
<p><em>layer</em></p>
<p>&nbsp;&nbsp; The layer to be drawn.</p>
<p><em>transform</em></p>
<p>&nbsp;&nbsp; Transformation of the layer drawn.</p>
<p><em>blendMode</em></p>
<p>&nbsp;&nbsp; The blend mode used.</p>
<p><em>antiAliasedEdges</em></p>
<p>&nbsp;&nbsp; Flag indicating whether or not to anti-alias the edges of the layer drawn. The anti-aliasing accomplished by drawing a thin gradient stripes going to alpha 0, along the edges.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; The layer must use a texture storage. The content is drawn transformed with the transform parameter.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:" title="drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:"></a></p>
<h4>drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:</h4>
<p>Draws a stroke in the current target with the provided parameters. The method will check the bounds of each segment (the curve between two control points) against the <a href="index.html#//api/name/clipRect">clipRect</a> set for this target. It will return the the bounding box of the stroke. (<b class="deprecated">Deprecated:</b><span class="deprecated"> This method very elaborate. The recommended way for drawing strokes in version 1.3 is to use an instance of the WCMStrokeRender class.</span>)  </p>
<pre><code class="objectivec">- (CGRect)drawStrokeWithBrush:(WCMStrokeBrush *)brush andControlPointsBeginning:(float *)controlPointsBeginning andBufferSize:(size_t)bufferSize andStride:(int)stride andWidth:(float)width andColor:(UIColor *)color andRoundCapBeginning:(bool)roundCapBeginning andRoundCapEnding:(bool)roundCapEnding</code></pre>
<h5>Parameters</h5>
<p><em>brush</em></p>
<p>&nbsp;&nbsp; Instance of the <a href="../api-WCMStrokeBrush/index.html">WCMStrokeBrush</a> class that determines how the stroke is going to be rendered.</p>
<p><em>controlPointsBeginning</em></p>
<p>&nbsp;&nbsp; pointer to the control points array.</p>
<p><em>bufferSize</em></p>
<p>&nbsp;&nbsp; size of the control points array.</p>
<p><em>stride</em></p>
<p>&nbsp;&nbsp; stride of the control points buffer. That is the offset from one control point to the next.</p>
<p><em>width</em></p>
<p>&nbsp;&nbsp; The width of the stroke. If the stroke has a variable width which is included in the control points array, this parameter must be NAN.</p>
<p><em>color</em></p>
<p>&nbsp;&nbsp; The color of the stroke.</p>
<p><em>roundCapBeginning</em></p>
<p>&nbsp;&nbsp; Cap the stroke with a circle at the start.</p>
<p><em>roundCapEnding</em></p>
<p>&nbsp;&nbsp; Cap the stroke with a circle at the end.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; The bounding box of the stroke drawn.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:andTs:andTf:andLastParticle:andRandomSeed:" title="drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:andTs:andTf:andLastParticle:andRandomSeed:"></a></p>
<h4>drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:andTs:andTf:andLastParticle:andRandomSeed:</h4>
<p>Draws a stroke in the current target with the provided parameters. The method will check the bounds of each segment (the curve between two control points) against the <a href="index.html#//api/name/clipRect">clipRect</a> set for this target. It will return the the bounding box of the stroke. (<b class="deprecated">Deprecated:</b><span class="deprecated"> This method very elaborate. The recommended way for drawing strokes in version 1.3 is to use an instance of the WCMStrokeRender class.</span>)  </p>
<pre><code class="objectivec">- (CGRect)drawStrokeWithBrush:(WCMStrokeBrush *)brush andControlPointsBeginning:(float *)controlPointsBeginning andBufferSize:(size_t)bufferSize andStride:(int)stride andWidth:(float)width andColor:(UIColor *)color andRoundCapBeginning:(bool)roundCapBeginning andRoundCapEnding:(bool)roundCapEnding andTs:(float)ts andTf:(float)tf andLastParticle:(WCMStrokePoint *)lastParticle andRandomSeed:(uint32_t *)randomGeneratorSeed</code></pre>
<h5>Parameters</h5>
<p><em>brush</em></p>
<p>&nbsp;&nbsp; Instance of the <a href="../api-WCMStrokeBrush/index.html">WCMStrokeBrush</a> class that determines how the stroke is going to be rendered.</p>
<p><em>controlPointsBeginning</em></p>
<p>&nbsp;&nbsp; pointer to the control points array.</p>
<p><em>bufferSize</em></p>
<p>&nbsp;&nbsp; size of the control points array.</p>
<p><em>stride</em></p>
<p>&nbsp;&nbsp; stride of the control points buffer. That is the offset from one control point to the next.</p>
<p><em>width</em></p>
<p>&nbsp;&nbsp; The width of the stroke. If the stroke has a variable thickness which is included in the control points array, this parameter must be NAN.</p>
<p><em>color</em></p>
<p>&nbsp;&nbsp; The color of the stroke.</p>
<p><em>roundCapBeginning</em></p>
<p>&nbsp;&nbsp; Cap the stroke with a circle at the start.</p>
<p><em>roundCapEnding</em></p>
<p>&nbsp;&nbsp; Cap the stroke with a circle at the end.</p>
<p><em>ts</em></p>
<p>&nbsp;&nbsp; The starting value for the Catmull-Rom spline parameter of the first curve of spline (0 is the default value).</p>
<p><em>tf</em></p>
<p>&nbsp;&nbsp; The final value for the Catmull-Rom spline parameter of the last curve of the spline (1 is the default value).</p>
<p><em>lastParticle</em></p>
<p>&nbsp;&nbsp; Pointer the last rendered particle. This parameter is relevant only for strokes drawn with particle brush. Upon completion it will store the position and with of the last drawn particle. This way you are able to draw a single stroke with several successive draw calls. Each draw call will continue from state (particle position and width) at which the previous draw call finished. You can pass <em>NULL</em>.</p>
<p><em>randomGeneratorSeed</em></p>
<p>&nbsp;&nbsp; Seed for the random number generator used for the stroke rendering. This parameter is relevant only for strokes drawn with particle brush. The stroke will look exactly the same every time you draw it with the same randomGeneratorSeed. If you pass <em>NULL</em> a new seed will be generated automatically.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; The bounding box of the stroke drawn.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:andTs:andTf:andLastParticle:andRandomSeed:andCheckBounds:" title="drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:andTs:andTf:andLastParticle:andRandomSeed:andCheckBounds:"></a></p>
<h4>drawStrokeWithBrush:andControlPointsBeginning:andBufferSize:andStride:andWidth:andColor:andRoundCapBeginning:andRoundCapEnding:andTs:andTf:andLastParticle:andRandomSeed:andCheckBounds:</h4>
<p>Draws a stroke in the current target with the provided parameters. (<b class="deprecated">Deprecated:</b><span class="deprecated"> This method very elaborate. The recommended way for drawing strokes in version 1.3 is to use an instance of the WCMStrokeRender class.</span>)   </p>
<pre><code class="objectivec">- (CGRect)drawStrokeWithBrush:(WCMStrokeBrush *)brush andControlPointsBeginning:(float *)controlPointsBeginning andBufferSize:(size_t)bufferSize andStride:(size_t)stride andWidth:(float)width andColor:(UIColor *)color andRoundCapBeginning:(bool)roundCapBeginning andRoundCapEnding:(bool)roundCapEnding andTs:(float)ts andTf:(float)tf andLastParticle:(WCMStrokePoint *)lastParticle andRandomSeed:(uint32_t *)randomGeneratorSeed andCheckBounds:(BOOL)checkBounds</code></pre>
<h5>Parameters</h5>
<p><em>brush</em></p>
<p>&nbsp;&nbsp; Instance of the <a href="../api-WCMStrokeBrush/index.html">WCMStrokeBrush</a> class that determines how the stroke is going to be rendered.</p>
<p><em>controlPointsBeginning</em></p>
<p>&nbsp;&nbsp; pointer to the control points array.</p>
<p><em>bufferSize</em></p>
<p>&nbsp;&nbsp; size of the control points array.</p>
<p><em>stride</em></p>
<p>&nbsp;&nbsp; stride of the control points buffer. That is the offset from one control point to the next.</p>
<p><em>width</em></p>
<p>&nbsp;&nbsp; The width of the stroke. If the stroke has a variable thickness which is included in the control points array, this parameter must be NAN.</p>
<p><em>color</em></p>
<p>&nbsp;&nbsp; The color of the stroke.</p>
<p><em>roundCapBeginning</em></p>
<p>&nbsp;&nbsp; Cap the stroke with a circle at the start.</p>
<p><em>roundCapEnding</em></p>
<p>&nbsp;&nbsp; Cap the stroke with a circle at the end.</p>
<p><em>ts</em></p>
<p>&nbsp;&nbsp; The starting value for the Catmull-Rom spline parameter of the first curve of spline (0 is the default value).</p>
<p><em>tf</em></p>
<p>&nbsp;&nbsp; The final value for the Catmull-Rom spline parameter of the last curve of the spline (1 is the default value).</p>
<p><em>lastParticle</em></p>
<p>&nbsp;&nbsp; Pointer the last rendered particle. This parameter is relevant only for strokes drawn with particle brush. Upon completion it will store the position and with of the last drawn particle. This way you are able to draw a single stroke with several successive draw calls. Each draw call will continue from state (particle position and width) at which the previous draw call finished. You can pass <em>NULL</em>.</p>
<p><em>randomGeneratorSeed</em></p>
<p>&nbsp;&nbsp; Seed for the random number generator used for the stroke rendering. This parameter is relevant only for strokes drawn with particle brush. The stroke will look exactly the same every time you draw it with the same randomGeneratorSeed. If you pass <em>NULL</em> a new seed will be generated automatically.</p>
<p><em>checkBounds</em></p>
<p>&nbsp;&nbsp; If set to YES the renderer will check the bounds of each segment (the curve between two control points) agains the <a href="index.html#//api/name/clipRect">clipRect</a> of the current rendering target. This could lead to a performance gain if big parts of the stroke are outside the <a href="index.html#//api/name/clipRect">clipRect</a>. On the other hand, if you are certain that most of stroke lays inside the <a href="index.html#//api/name/clipRect">clipRect</a>, it is better to set it to NO. Note that setting this to NO will cause the method to always return CGRectNull, because it will skip bounds calculation all together.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; The bounding box of the stroke drawn. <b>If checkBounds is set to NO, bounds calculation will be skipped and the method will always return CGRectNull.</b></p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/fillPath:andBufferSize:andStride:andColor:andAntiAliased:" title="fillPath:andBufferSize:andStride:andColor:andAntiAliased:"></a></p>
<h4>fillPath:andBufferSize:andStride:andColor:andAntiAliased:</h4>
<p>Fills the interior of a path with a solid color. The path is defined by a list of Catmull-Rom spline control points. The path will be close automatically.  </p>
<pre><code class="objectivec">- (void)fillPath:(float *)controlPoints andBufferSize:(size_t)bufferSize andStride:(int)stride andColor:(UIColor *)color andAntiAliased:(BOOL)antiAliased</code></pre>
<h5>Parameters</h5>
<p><em>controlPoints</em></p>
<p>&nbsp;&nbsp; Pointer to the control points array.</p>
<p><em>bufferSize</em></p>
<p>&nbsp;&nbsp; Size of the control points array.</p>
<p><em>stride</em></p>
<p>&nbsp;&nbsp; Stride of the control points array. Stride is the distance between points beginnings.</p>
<p><em>color</em></p>
<p>&nbsp;&nbsp; The fill color.</p>
<p><em>antiAliased</em></p>
<p>&nbsp;&nbsp; Whether or not to anti-alias the edges of the path. Default value is NO. <strong>If you set it to YES, due to implementation limitations, the path's filled area will blend correctly only when the target layer is cleared with black color.</strong></p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/initWithEAGLContext:" title="initWithEAGLContext:"></a></p>
<h4>initWithEAGLContext:</h4>
<p>Initializes a newly allocated WCMRenderingContext with a EAGLContext.   </p>
<pre><code class="objectivec">- (id)initWithEAGLContext:(EAGLContext *)eaglContext</code></pre>
<h5>Parameters</h5>
<p><em>eaglContext</em></p>
<p>&nbsp;&nbsp; The EAGLContext instance associated with the rendering context. All OpengGL operations and resources (like textures or render buffers) will be for this context.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; an initialized instance of the WCMRenderingContext class.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; Initializes a newly allocated WCMRenderingContext with a EAGLContext.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/layerFromEAGLDrawable:withScaleFactor:" title="layerFromEAGLDrawable:withScaleFactor:"></a></p>
<h4>layerFromEAGLDrawable:withScaleFactor:</h4>
<p>Creates a layer associated with a EAGLDrawable. The layer will internally create a frameBuffer and a renderBuffer. The render buffer storage will be the EAGLDrawable. The size of the layer will be equal to the size of the EAGLDrawable divided by the scaleFactor (note that the storageWidth and storageHeight of the layer will always be equal to the EAGLDrawable's width and height).  </p>
<pre><code class="objectivec">- (WCMLayer *)layerFromEAGLDrawable:(id&amp;lt;EAGLDrawable&amp;gt;)eaglDrawable withScaleFactor:(float)scaleFactor</code></pre>
<h5>Parameters</h5>
<p><em>eaglDrawable</em></p>
<p>&nbsp;&nbsp; The EAGLDrawable instance with which the layer will be associated.</p>
<p><em>scaleFactor</em></p>
<p>&nbsp;&nbsp; Layer's scale factor. See <a href="../api-WCMLayer/index.html#//api/name/scaleFactor">[WCMLayer scaleFactor]</a>.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; a layer associated with a EAGLDrawable. The layer will internally create a frameBuffer and a renderBuffer. The renderBuffer will associates with the EAGLDrawable. The size of the layer will be equal to the size of the EAGLDrawable divided by the scaleFactor. The layer will free the OpenGL resource when deallocated.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/layerWithWidth:andHeight:" title="layerWithWidth:andHeight:"></a></p>
<h4>layerWithWidth:andHeight:</h4>
<p>Creates a layer with width and height. Scale factor of the layer is set to 1.0. The layer will use an OpenGL texture as a storage.  </p>
<pre><code class="objectivec">- (WCMLayer *)layerWithWidth:(int)width andHeight:(int)height</code></pre>
<h5>Parameters</h5>
<p><em>width</em></p>
<p>&nbsp;&nbsp; Layer's width. See <a href="../api-WCMLayer/index.html#//api/name/width">[WCMLayer width]</a>.</p>
<p><em>height</em></p>
<p>&nbsp;&nbsp; Layer's height. See <a href="../api-WCMLayer/index.html#//api/name/height">[WCMLayer height]</a>.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; layer with width and height. Scale factor of the layer is set to 1.0. The layer will use an OpenGL texture as a storage.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/layerWithWidth:andHeight:andScaleFactor:" title="layerWithWidth:andHeight:andScaleFactor:"></a></p>
<h4>layerWithWidth:andHeight:andScaleFactor:</h4>
<p>Creates a layer with width, height and scale factor. The layer will use a OpenGL texture as a storage. The layer will be filled with black color with alpha 0.  </p>
<pre><code class="objectivec">- (WCMLayer *)layerWithWidth:(int)width andHeight:(int)height andScaleFactor:(int)scaleFactor</code></pre>
<h5>Parameters</h5>
<p><em>width</em></p>
<p>&nbsp;&nbsp; Layer's width. See <a href="../api-WCMLayer/index.html#//api/name/width">[WCMLayer width]</a>.</p>
<p><em>height</em></p>
<p>&nbsp;&nbsp; Layer's height. See <a href="../api-WCMLayer/index.html#//api/name/height">[WCMLayer height]</a>.</p>
<p><em>scaleFactor</em></p>
<p>&nbsp;&nbsp; Layer's scale factor. See <a href="../api-WCMLayer/index.html#//api/name/scaleFactor">[WCMLayer scaleFactor]</a>.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; layer with width, height and scaleFactor. The layer will use an OpenGL texture as a storage.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/layerWithWidth:andHeight:andScaleFactor:andGlFramebufferId:andGlRenderbufferId:andGlTextureId:ownGlResources:" title="layerWithWidth:andHeight:andScaleFactor:andGlFramebufferId:andGlRenderbufferId:andGlTextureId:ownGlResources:"></a></p>
<h4>layerWithWidth:andHeight:andScaleFactor:andGlFramebufferId:andGlRenderbufferId:andGlTextureId:ownGlResources:</h4>
<p>Creates a layer with width, height, scale factor and a combination of already created OpenGL resources - frameBuffer, renderBuffer or texture. The content of the renderBuffer or texture will NOT be changed in any way.   </p>
<pre><code class="objectivec">- (WCMLayer *)layerWithWidth:(int)width andHeight:(int)height andScaleFactor:(int)scaleFactor andGlFramebufferId:(unsigned int)framebufferId andGlRenderbufferId:(unsigned int)renderbufferId andGlTextureId:(unsigned int)textureId ownGlResources:(BOOL)ownGlResources</code></pre>
<h5>Parameters</h5>
<p><em>width</em></p>
<p>&nbsp;&nbsp; Layer's width. See <a href="../api-WCMLayer/index.html#//api/name/width">[WCMLayer width]</a>.</p>
<p><em>height</em></p>
<p>&nbsp;&nbsp; Layer's height. See <a href="../api-WCMLayer/index.html#//api/name/height">[WCMLayer height]</a>.</p>
<p><em>scaleFactor</em></p>
<p>&nbsp;&nbsp; Layer's scale factor. See <a href="../api-WCMLayer/index.html#//api/name/scaleFactor">[WCMLayer scaleFactor]</a>.</p>
<p><em>framebufferId</em></p>
<p>&nbsp;&nbsp; A frameBuffer identifier. If frameBuffer is set to 0, the layer could NOT be a target to a draw operation.</p>
<p><em>renderbufferId</em></p>
<p>&nbsp;&nbsp; A render-buffer identifier. Only one of the renderbufferId and textureId should be set (the other one should be 0).</p>
<p><em>textureId</em></p>
<p>&nbsp;&nbsp; A texture identifier. Only one of the renderbufferId and textureId should be set (the other one should be 0).</p>
<p><em>ownGlResources</em></p>
<p>&nbsp;&nbsp; If YES, when the layer is deallocated, the OpenGL resources (framebufferId, textureId, renderbufferId) will be deleted. If NO, the layer will not take responsibility for freeing the OpenGL resources.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; a layer with width, height, scale factor and a combination of already created OpenGL resources - frameBuffer, renderBuffer or texture.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; If a frameBuffer is set, the layer could be destination for rendering operations. If frameBuffer is set to 0, the layer could not be such destination. It could only be drawn in other layers.</p>
<p>It is expected only one of the glRenderbufferId and textureId set (the other one should be set to 0).</p>
<p>If ownGlResources is se to YES the Layer will delete the OpenGL resources when the instance is deallocated, otherwise the management of the OpenGL resources is a responsibility of the caller of the method.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/layerWithWidth:andHeight:andScaleFactor:andUseTextureStorage:" title="layerWithWidth:andHeight:andScaleFactor:andUseTextureStorage:"></a></p>
<h4>layerWithWidth:andHeight:andScaleFactor:andUseTextureStorage:</h4>
<p>Creates a layer with width, height and scaleFactor. Also specifies if the layer should will use texture or render buffer as a storage. The layer will be filled with black color with alpha 0.  </p>
<pre><code class="objectivec">- (WCMLayer *)layerWithWidth:(int)width andHeight:(int)height andScaleFactor:(int)scaleFactor andUseTextureStorage:(BOOL)useTextureStorage</code></pre>
<h5>Parameters</h5>
<p><em>width</em></p>
<p>&nbsp;&nbsp; Layer's width. See <a href="../api-WCMLayer/index.html#//api/name/width">[WCMLayer width]</a>.</p>
<p><em>height</em></p>
<p>&nbsp;&nbsp; Layer's height. See <a href="../api-WCMLayer/index.html#//api/name/height">[WCMLayer height]</a>.</p>
<p><em>scaleFactor</em></p>
<p>&nbsp;&nbsp; Layer's scale factor. See <a href="../api-WCMLayer/index.html#//api/name/scaleFactor">[WCMLayer scaleFactor]</a>.</p>
<p><em>useTextureStorage</em></p>
<p>&nbsp;&nbsp; Layer' use texture storage. See <a href="../api-WCMLayer/index.html#//api/name/useTextureStorage">[WCMLayer useTextureStorage]</a>.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; layer with width, height and scaleFactor. Also specifies if the layer should will use texture or render buffer as a storage.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; If useTextureStorage is YES, the content will be stored in OpenGL texture. If useTextureStorage is NO, the content will be stored in OpenGL renderBuffer.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/particleBrushWithFillImage:andShapeImage:andSpacing:andScattering:andBlendMode:andRotation:" title="particleBrushWithFillImage:andShapeImage:andSpacing:andScattering:andBlendMode:andRotation:"></a></p>
<h4>particleBrushWithFillImage:andShapeImage:andSpacing:andScattering:andBlendMode:andRotation:</h4>
<p>Creates and returns initialized <a href="../api-WCMStrokeBrush/index.html">WCMStrokeBrush</a> instance. Strokes drawn with this brush will be drawn using a large number of small textures (called particles), scattered along the stroke's trajectory.    </p>
<pre><code class="objectivec">- (WCMParticleStrokeBrush *)particleBrushWithFillImage:(UIImage *)fillTexture andShapeImage:(UIImage *)shapeTexture andSpacing:(CGFloat)spacing andScattering:(CGFloat)scattering andBlendMode:(WCMBlendMode)blendMode andRotation:(WCMStrokeBrushRotation)rotationMode</code></pre>
<h5>Parameters</h5>
<p><em>fillTexture</em></p>
<p>&nbsp;&nbsp; This image will fill the stroke. It will be repeated (tiled). Its dimension must be power of 2.</p>
<p><em>shapeTexture</em></p>
<p>&nbsp;&nbsp; This image used for each particle.</p>
<p><em>spacing</em></p>
<p>&nbsp;&nbsp; Defines the separation between particles. The value must be greater than 0. Value of 1.0 means that the distance between two particles will be equal the average width of the two particles.</p>
<p><em>scattering</em></p>
<p>&nbsp;&nbsp; Controls how much the particles will spread out sideways. Value of 0 means no spread out. Values of 1, means that each particle will be displaced sideways a random amount between 0% to 100% of its width.</p>
<p><em>blendMode</em></p>
<p>&nbsp;&nbsp; Specifies the blend mode with which each particle will be drawn.</p>
<p><em>rotationMode</em></p>
<p>&nbsp;&nbsp; Specifies the rotation mode applied to each particle. See <a href="../api-WCMStrokeBrushRotation/index.html">WCMStrokeBrushRotation</a>.</p>
<h5>Availability</h5>
<p>Available in <em>1.3</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; Strokes with this brush will be drawn using a large number of small textures (particles), scattered along the stroke's trajectory.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/particleBrushWithFillImage:andShapeMipmapLevelsImages:andSpacing:andScattering:andBlendMode:andRotation:" title="particleBrushWithFillImage:andShapeMipmapLevelsImages:andSpacing:andScattering:andBlendMode:andRotation:"></a></p>
<h4>particleBrushWithFillImage:andShapeMipmapLevelsImages:andSpacing:andScattering:andBlendMode:andRotation:</h4>
<p>Creates and returns initialized <a href="../api-WCMStrokeBrush/index.html">WCMStrokeBrush</a> instance. Strokes with this brush will be drawn using a large number of small textures (called particles), scattered along the stroke's trajectory. Instead of a single shape image, this method needs an array of images in different resolutions.  </p>
<pre><code class="objectivec">- (WCMParticleStrokeBrush *)particleBrushWithFillImage:(UIImage *)fillTexture andShapeMipmapLevelsImages:(NSArray *)shapeTextureLevels andSpacing:(CGFloat)spacing andScattering:(CGFloat)scattering andBlendMode:(WCMBlendMode)blendMode andRotation:(WCMStrokeBrushRotation)rotationMode</code></pre>
<h5>Parameters</h5>
<p><em>fillTexture</em></p>
<p>&nbsp;&nbsp; After the stroke's shape (contour) is generated, it will be filled by tiling the image specified by this argument. The UIImage's size, determines the size of the tile. Its dimensions must be a power of 2. If you need to specify different size for the tile, use the <a href="index.html#//api/name/particleBrushWithFillMipmapLevelsImages:andFillTileSize:andShapeMipmapLevelsImages:andSpacing:andScattering:andBlendMode:andRotation:">[WCMRenderingContext particleBrushWithFillMipmapLevelsImages:andFillTileSize:andShapeMipmapLevelsImages:andSpacing:andScattering:andBlendMode:andRotation:]</a> method instead.</p>
<p><em>shapeTextureLevels</em></p>
<p>&nbsp;&nbsp; Specifies several scale levels of the image used for each particle. You provide an array of images with different resolutions. The dimensions of each images must be a power of 2. The images must be provided in decreasing order of their dimensions. The dimensions of each image in the array must be exactly half of the dimensions of the previous one.</p>
<p><em>spacing</em></p>
<p>&nbsp;&nbsp; Defines the separation between particles. The value must be greater than 0. Value of 1.0 means that the distance between two particles will be equal the average width of the two particles.</p>
<p><em>scattering</em></p>
<p>&nbsp;&nbsp; Controls how much the particles will spread out sideways. Value of 0 means no spread out. Values of 1, means that each particle will be displaced sideways a random amount between 0% to 100% of its width.</p>
<p><em>blendMode</em></p>
<p>&nbsp;&nbsp; Specifies the blend mode with which each particle will be drawn.</p>
<p><em>rotationMode</em></p>
<p>&nbsp;&nbsp; Specifies the rotation mode applied to each particle. See <a href="../api-WCMStrokeBrushRotation/index.html">WCMStrokeBrushRotation</a>.</p>
<h5>Availability</h5>
<p>Available in <em>1.3</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; Strokes with this brush will be drawn using a large number of small textures (particles), scattered along the stroke's trajectory.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/particleBrushWithFillMipmapLevelsImages:andFillTileSize:andShapeMipmapLevelsImages:andSpacing:andScattering:andBlendMode:andRotation:" title="particleBrushWithFillMipmapLevelsImages:andFillTileSize:andShapeMipmapLevelsImages:andSpacing:andScattering:andBlendMode:andRotation:"></a></p>
<h4>particleBrushWithFillMipmapLevelsImages:andFillTileSize:andShapeMipmapLevelsImages:andSpacing:andScattering:andBlendMode:andRotation:</h4>
<p>Creates and returns initialized <a href="../api-WCMStrokeBrush/index.html">WCMStrokeBrush</a> instance. Strokes with this brush will be drawn using a large number of small textures (called particles), scattered along the stroke's trajectory. Instead of a single shape image, this method needs an array of images in different resolutions.  </p>
<pre><code class="objectivec">- (WCMParticleStrokeBrush *)particleBrushWithFillMipmapLevelsImages:(NSArray *)fillTextureLevels andFillTileSize:(CGSize)fillTileSize andShapeMipmapLevelsImages:(NSArray *)shapeTextureLevels andSpacing:(CGFloat)spacing andScattering:(CGFloat)scattering andBlendMode:(WCMBlendMode)blendMode andRotation:(WCMStrokeBrushRotation)rotationMode</code></pre>
<h5>Parameters</h5>
<p><em>fillTextureLevels</em></p>
<p>&nbsp;&nbsp; Specifies several scale levels of the image used for tiling. After the stroke's shape (contour) is generated, it will be filled by tiling the image specified by this argument. The size of the tile is set by the fillTileSize argument. You provide an array of images with different resolutions. The dimensions of each images must be a power of 2. The images must be provided in decreasing order of their dimensions. The dimensions of each image in the array must be exactly half of the dimensions of the previous one.</p>
<p><em>fillTileSize</em></p>
<p>&nbsp;&nbsp; The size of the tile used to fill the stroke. The tile will be filled with content of the images defined by the fillTextureLevels.</p>
<p><em>shapeTextureLevels</em></p>
<p>&nbsp;&nbsp; Specifies several scale levels of the image used for each particle. You provide an array of images with different resolutions. The dimensions of each images must be a power of 2. The images must be provided in decreasing order of their dimensions. The dimensions of each image in the array must be exactly half of the dimensions of the previous one.</p>
<p><em>spacing</em></p>
<p>&nbsp;&nbsp; Defines the separation between particles. The value must be greater than 0. Value of 1.0 means that the distance between two particles will be equal the average width of the two particles.</p>
<p><em>scattering</em></p>
<p>&nbsp;&nbsp; Controls how much the particles will spread out sideways. Value of 0 means no spread out. Values of 1, means that each particle will be displaced sideways a random amount between 0% to 100% of its width.</p>
<p><em>blendMode</em></p>
<p>&nbsp;&nbsp; Specifies the blend mode with which each particle will be drawn.</p>
<p><em>rotationMode</em></p>
<p>&nbsp;&nbsp; Specifies the rotation mode applied to each particle. See <a href="../api-WCMStrokeBrushRotation/index.html">WCMStrokeBrushRotation</a>.</p>
<h5>Availability</h5>
<p>Available in <em>1.3</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; Strokes with this brush will be drawn using a large number of small textures (particles), scattered along the stroke's trajectory.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/particleBrushWithPaint:" title="particleBrushWithPaint:"></a></p>
<h4>particleBrushWithPaint:</h4>
<p>Creates and returns initialized <a href="../api-WCMParticleStrokeBrush/index.html">WCMParticleStrokeBrush</a> instance using a <a href="../api-WCMParticlePaint/index.html">WCMParticlePaint</a> definition class instance.   </p>
<pre><code class="objectivec">- (WCMParticleStrokeBrush *)particleBrushWithPaint:(WCMParticlePaint *)paint</code></pre>
<h5>Parameters</h5>
<p><em>paint</em></p>
<p>&nbsp;&nbsp; Instance of the <a href="../api-WCMParticlePaint/index.html">WCMParticlePaint</a> class used to initialized the instance.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; initialized <a href="../api-WCMParticleStrokeBrush/index.html">WCMParticleStrokeBrush</a> instance using a <a href="../api-WCMParticlePaint/index.html">WCMParticlePaint</a> definition class instance.</p>
<h5>Availability</h5>
<p>Available in <em>1.3</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/readPixelsAsUIImageFromCurrentTarget" title="readPixelsAsUIImageFromCurrentTarget"></a></p>
<h4>readPixelsAsUIImageFromCurrentTarget</h4>
<p>Returns an UIImage containing all the pixels of the layer set as a current target of the context.   </p>
<pre><code class="objectivec">- (UIImage *)readPixelsAsUIImageFromCurrentTarget</code></pre>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; An UIImage containing all the pixels of the layer set as a current target of the context.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/readPixelsAsUIImageFromCurrentTargetFromRect:" title="readPixelsAsUIImageFromCurrentTargetFromRect:"></a></p>
<h4>readPixelsAsUIImageFromCurrentTargetFromRect:</h4>
<p>Returns an UIImage containing the pixels of the layer set as a current target of the context, from the rectangle specified by the rect parameter.   </p>
<pre><code class="objectivec">- (UIImage *)readPixelsAsUIImageFromCurrentTargetFromRect:(CGRect)rect</code></pre>
<h5>Parameters</h5>
<p><em>rect</em></p>
<p>&nbsp;&nbsp; The area from which the pixels are read.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; An UIImage containing the pixels of the layer set as a current target of the context, from the rectangle specified by the rect parameter.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/readPixelsAsUIImageFromCurrentTargetFromRectInUpOrientation:" title="readPixelsAsUIImageFromCurrentTargetFromRectInUpOrientation:"></a></p>
<h4>readPixelsAsUIImageFromCurrentTargetFromRectInUpOrientation:</h4>
<p>Returns an UIImage containing the pixels of the layer set as a current target of the context, from the rectangle specified by the rect parameter.
Unlike the <a href="index.html#//api/name/readPixelsAsUIImageFromCurrentTargetFromRect:">[WCMRenderingContext readPixelsAsUIImageFromCurrentTargetFromRect:]</a>, the result will be in UIImageOrientationUp. The method performs extra conversion work and is slightly slower than <a href="index.html#//api/name/readPixelsAsUIImageFromCurrentTargetFromRect:">[WCMRenderingContext readPixelsAsUIImageFromCurrentTargetFromRect:]</a>.    </p>
<pre><code class="objectivec">- (UIImage *)readPixelsAsUIImageFromCurrentTargetFromRectInUpOrientation:(CGRect)rect</code></pre>
<h5>Parameters</h5>
<p><em>rect</em></p>
<p>&nbsp;&nbsp; The area from which the pixels are read.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; An UIImage containing the pixels of the layer set as a current target of the context, from the rectangle specified by the rect parameter.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/readPixelsAsUIImageFromCurrentTargetInUpOrientation" title="readPixelsAsUIImageFromCurrentTargetInUpOrientation"></a></p>
<h4>readPixelsAsUIImageFromCurrentTargetInUpOrientation</h4>
<p>Returns an UIImage containing all the pixels of the layer set as a current target of the context.
Unlike the <a href="index.html#//api/name/readPixelsAsUIImageFromCurrentTarget">readPixelsAsUIImageFromCurrentTarget</a>, the result will be in UIImageOrientationUp. The method performs extra conversion work and is slightly slower than <a href="index.html#//api/name/readPixelsAsUIImageFromCurrentTarget">readPixelsAsUIImageFromCurrentTarget</a>.    </p>
<pre><code class="objectivec">- (UIImage *)readPixelsAsUIImageFromCurrentTargetInUpOrientation</code></pre>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; An UIImage containing all the pixels of the layer set as a current target of the context.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/readPixelsFromCurrentTarget" title="readPixelsFromCurrentTarget"></a></p>
<h4>readPixelsFromCurrentTarget</h4>
<p>Returns all the pixels of the layer set as a current target of the context. </p>
<pre><code class="objectivec">- (NSData *)readPixelsFromCurrentTarget</code></pre>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; All the pixels of the layer set as a current target of the context.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/readPixelsFromCurrentTargetFromRect:" title="readPixelsFromCurrentTargetFromRect:"></a></p>
<h4>readPixelsFromCurrentTargetFromRect:</h4>
<p>Returns the pixels of the layer set as a current target of the context, from the rectangle specified by the rect parameter. </p>
<pre><code class="objectivec">- (NSData *)readPixelsFromCurrentTargetFromRect:(CGRect)rect</code></pre>
<h5>Parameters</h5>
<p><em>rect</em></p>
<p>&nbsp;&nbsp; The area from which the pixels are read.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; The pixels of the layer set as a current target of the context, from the rectangle specified by the rect parameter.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/resizeLayer:withEAGLDrawable:" title="resizeLayer:withEAGLDrawable:"></a></p>
<h4>resizeLayer:withEAGLDrawable:</h4>
<p>Sets a new size of the layer using the size of the provided EAGLDrawable instance. You should call this method for layers created using the <a href="index.html#//api/name/layerFromEAGLDrawable:withScaleFactor:">[WCMRenderingContext layerFromEAGLDrawable:withScaleFactor:]</a>, when the EAGLDrawable has changed its size. </p>
<pre><code class="objectivec">- (WCMLayer *)resizeLayer:(WCMLayer *)layer withEAGLDrawable:(id&amp;lt;EAGLDrawable&amp;gt;)eaglDrawable</code></pre>
<h5>Parameters</h5>
<p><em>layer</em></p>
<p>&nbsp;&nbsp; The layer that is going to be resized.</p>
<p><em>eaglDrawable</em></p>
<p>&nbsp;&nbsp; The EAGLDrawable used when the layer was created. It will determine the new size of the layer.</p>
<h5>Availability</h5>
<p>Available in <em>1.5</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/resizeLayer:withSize:" title="resizeLayer:withSize:"></a></p>
<h4>resizeLayer:withSize:</h4>
<p>Sets a new size of the layer. The underlying OpenGL texture or render buffer will be recreated with a new size. The content of the buffer(texture) will be undefined. You have the responsibility to set the content for the new size.  </p>
<pre><code class="objectivec">- (WCMLayer *)resizeLayer:(WCMLayer *)layer withSize:(CGSize)size</code></pre>
<h5>Parameters</h5>
<p><em>layer</em></p>
<p>&nbsp;&nbsp; The layer that is going to be resized.</p>
<p><em>size</em></p>
<p>&nbsp;&nbsp; The new size of the layer.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; The layer resized layer.</p>
<h5>Availability</h5>
<p>Available in <em>1.5</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/setTarget:" title="setTarget:"></a></p>
<h4>setTarget:</h4>
<p>Sets the layer that will be the target of the rendering operations. </p>
<pre><code class="objectivec">- (void)setTarget:(WCMLayer *)layer</code></pre>
<h5>Parameters</h5>
<p><em>layer</em></p>
<p>&nbsp;&nbsp; The target layer</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/setTarget:andClipRect:" title="setTarget:andClipRect:"></a></p>
<h4>setTarget:andClipRect:</h4>
<p>Sets the layer that will be the target of the rendering operations. Also sets a clipping rect. The clipping rect corresponds to the OpenGL's glScissors function. The <a href="index.html#//api/name/clipRect">clipRect</a> enables us block out the parts of the layer outside the rectangle, that we dont to be affected by draw operations. Setting a smaller <a href="index.html#//api/name/clipRect">clipRect</a> could also be performance optimization, when we know where we will draw.  </p>
<pre><code class="objectivec">- (void)setTarget:(WCMLayer *)layer andClipRect:(CGRect)clipRect</code></pre>
<h5>Parameters</h5>
<p><em>layer</em></p>
<p>&nbsp;&nbsp; The layer to be set as current.</p>
<p><em>clipRect</em></p>
<p>&nbsp;&nbsp; The clipping rectangle to be set.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/setTargetClipRect:" title="setTargetClipRect:"></a></p>
<h4>setTargetClipRect:</h4>
<p>Set a clipping rect of the current target. The clipping rect corresponds to the OpenGL's glScissors function. The <a href="index.html#//api/name/clipRect">clipRect</a> enables us block out the parts of the layer outside the rectangle, that we dont to be affected by draw operations. Setting a smaller <a href="index.html#//api/name/clipRect">clipRect</a> could also be performance optimization, when we know where we will draw.  </p>
<pre><code class="objectivec">- (void)setTargetClipRect:(CGRect)clipRect</code></pre>
<h5>Parameters</h5>
<p><em>clipRect</em></p>
<p>&nbsp;&nbsp; The clipping rectangle to be set.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; This call will lead to a glScissor call. Note that this will be set only if the target is not changed. Every change of the target will disable the clipping rect.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/solidColorBrush" title="solidColorBrush"></a></p>
<h4>solidColorBrush</h4>
<p>Creates and returns initialized <a href="../api-WCMStrokeBrush/index.html">WCMStrokeBrush</a> instance. Strokes draw with this brush will be filled with a solid color.
Strokes drawn with this brush are guaranteed to be rendered correctly independent of paths drawn.
Unlike the <a href="../api-WCMDirectStrokeBrush/index.html">WCMDirectStrokeBrush</a>, which is faster but could produce &quot;glitches&quot; for paths which vary sharply in width. This is the recommended brush for solid color strokes.   </p>
<pre><code class="objectivec">- (WCMSolidColorStrokeBrush *)solidColorBrush</code></pre>
<h5>Availability</h5>
<p>Available in <em>1.3</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; This brush is designed to draw strokes in a dedicated layer. Later the content if that layer could be blended using a desired blend mode in another layer. The <a href="../api-WCMStrokeRenderer/index.html">WCMStrokeRenderer</a> class will handle the &quot;two step&quot; drawing process.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/strokeRendererWithSize:andScaleFactor:" title="strokeRendererWithSize:andScaleFactor:"></a></p>
<h4>strokeRendererWithSize:andScaleFactor:</h4>
<p>Creates a stroke painter with width and height and scale factor.    </p>
<pre><code class="objectivec">- (WCMStrokeRenderer *)strokeRendererWithSize:(CGSize)size andScaleFactor:(CGFloat)scaleFactor</code></pre>
<h5>Parameters</h5>
<p><em>size</em></p>
<p>&nbsp;&nbsp; The size of the internal layers created by the painter.</p>
<p><em>scaleFactor</em></p>
<p>&nbsp;&nbsp; The scale factor of the internal layers created by the painter.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; stroke painter with width and height and scale factor.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/strokeRenderertWithBufferLayer:" title="strokeRenderertWithBufferLayer:"></a></p>
<h4>strokeRenderertWithBufferLayer:</h4>
<p>Creates a stroke painter with existing <a href="../api-WCMLayer/index.html">WCMLayer</a> as it s internal storage layer.   </p>
<pre><code class="objectivec">- (WCMStrokeRenderer *)strokeRenderertWithBufferLayer:(WCMLayer *)strokeBufferLayer</code></pre>
<h5>Parameters</h5>
<p><em>strokeBufferLayer</em></p>
<p>&nbsp;&nbsp; The layer that will be used for storing the stroke's pixel.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; a stroke painter with existing <a href="../api-WCMLayer/index.html">WCMLayer</a> as it s internal storage layer.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/strokeRenderertWithBufferLayer:andPreliminaryBufferLayer:" title="strokeRenderertWithBufferLayer:andPreliminaryBufferLayer:"></a></p>
<h4>strokeRenderertWithBufferLayer:andPreliminaryBufferLayer:</h4>
<p>Creates a stroke painter with existing WCMLayer's as it s internal storage layers.  </p>
<pre><code class="objectivec">- (WCMStrokeRenderer *)strokeRenderertWithBufferLayer:(WCMLayer *)strokeBufferLayer andPreliminaryBufferLayer:(WCMLayer *)strokePreliminaryBufferLayer</code></pre>
<h5>Parameters</h5>
<p><em>strokeBufferLayer</em></p>
<p>&nbsp;&nbsp; The layer that will be used for storing the stroke's pixel.</p>
<p><em>strokePreliminaryBufferLayer</em></p>
<p>&nbsp;&nbsp; The layer that will be used for storing the stroke's preliminary curve pixels.</p>
<h5>Return Value</h5>
<p>&nbsp;&nbsp; a stroke painter with existing WCMLayer's as it s internal storage layers.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/writePixelsInCurrentTarget:" title="writePixelsInCurrentTarget:"></a></p>
<h4>writePixelsInCurrentTarget:</h4>
<p>Sets all the pixels of the layer set as a current target of the context.    </p>
<pre><code class="objectivec">- (void)writePixelsInCurrentTarget:(NSData *)pixels</code></pre>
<h5>Parameters</h5>
<p><em>pixels</em></p>
<p>&nbsp;&nbsp; NSData containing the pixels.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; The length of the pixels must corresponds to the storageBounds of the layer.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/writePixelsInCurrentTarget:inRect:" title="writePixelsInCurrentTarget:inRect:"></a></p>
<h4>writePixelsInCurrentTarget:inRect:</h4>
<p>Sets the pixels of the area defined by the rect, of the layer set as a current target of the context.   </p>
<pre><code class="objectivec">- (void)writePixelsInCurrentTarget:(NSData *)pixels inRect:(CGRect)rect</code></pre>
<h5>Parameters</h5>
<p><em>pixels</em></p>
<p>&nbsp;&nbsp; NSData containing the pixels.</p>
<p><em>rect</em></p>
<p>&nbsp;&nbsp; CGRect defining the area</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; The length of the pixels must corresponds to the rect scaled by the <a href="../api-WCMLayer/index.html#//api/name/scaleFactor">[WCMLayer scaleFactor]</a> of the layer.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/writePixelsInCurrentTargetFromUIImage:" title="writePixelsInCurrentTargetFromUIImage:"></a></p>
<h4>writePixelsInCurrentTargetFromUIImage:</h4>
<p>Sets all the pixels of the layer set as a current target of the context.    </p>
<pre><code class="objectivec">- (void)writePixelsInCurrentTargetFromUIImage:(UIImage *)image</code></pre>
<h5>Parameters</h5>
<p><em>image</em></p>
<p>&nbsp;&nbsp; UIImage containing the pixels.</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; The size of the image must corresponds to the storageBounds of the layer.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<p><a name="//api/name/writePixelsInCurrentTargetFromUIImage:inRect:" title="writePixelsInCurrentTargetFromUIImage:inRect:"></a></p>
<h4>writePixelsInCurrentTargetFromUIImage:inRect:</h4>
<p>Sets the pixels of the area defined by the rect, of the layer set as a current target of the context.   </p>
<pre><code class="objectivec">- (void)writePixelsInCurrentTargetFromUIImage:(UIImage *)image inRect:(CGRect)rect</code></pre>
<h5>Parameters</h5>
<p><em>image</em></p>
<p>&nbsp;&nbsp; UIImage containing the pixels.</p>
<p><em>rect</em></p>
<p>&nbsp;&nbsp; CGRect defining the area</p>
<h5>Availability</h5>
<p>Available in <em>1.2</em> and later.</p>
<h5>Discussion</h5>
<p>&nbsp;&nbsp; The size of the image must corresponds to the rect scaled by the <a href="../api-WCMLayer/index.html#//api/name/scaleFactor">[WCMLayer scaleFactor]</a> of the layer.</p>
<h5>Declared In</h5>
<p>WacomInkRasterizer.h    </p>
<hr />
<p><a href="../api-index/index.html">Index</a> | <a href="../api-hierarchy/index.html">Hierarchy</a></p>
</div> <!-- page -->
</div> <!-- page_content -->

	</div><!-- #sitewrapper -->

	<footer>
		<img src="../../wp-content/themes/will-doc/images/img_logo_wacom.png" alt="" />
<!--
		<span>&nbsp;</span>
		<a href="/contact.html">Contact</a>
		<a href="/support.html">Support</a>
-->
	</footer>
</body>
</html>